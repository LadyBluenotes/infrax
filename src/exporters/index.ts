import type {
  ResolvedConfig,
  ExportResult,
  ExportTarget,
  McpExportTarget,
  RuleDefinition,
  McpServerDefinition,
} from "../types/index.js";
import { expandVariablesInObject } from "../utils/index.js";

/**
 * Generate a header for exported files.
 */
function generateHeader(
  resolved: ResolvedConfig,
  format: "markdown" | "json" | "yaml"
): string {
  const lines = [
    `Generated by infrax v${resolved.meta.version}`,
    `Config hash: ${resolved.meta.configHash}`,
    `Generated at: ${resolved.meta.timestamp}`,
    ``,
    `DO NOT EDIT THIS FILE DIRECTLY.`,
    `Edit your ai.config.jsonc and run 'infrax export' instead.`,
  ];

  if (format === "markdown") {
    return lines.map((l) => (l ? `<!-- ${l} -->` : "")).join("\n") + "\n\n";
  } else if (format === "json") {
    // JSON doesn't support comments, so we embed it as a field
    return ""; // We'll add _generated field instead
  } else {
    return lines.map((l) => (l ? `# ${l}` : "#")).join("\n") + "\n\n";
  }
}

/**
 * Filter rules for a specific export target.
 */
function filterRulesForTarget(
  rules: RuleDefinition[],
  target: ExportTarget
): RuleDefinition[] {
  return rules.filter((rule) => {
    // If no targets specified, include in all
    if (!rule.targets || rule.targets.length === 0) {
      return true;
    }
    return rule.targets.includes(target);
  });
}

// -----------------------------------------------------------------------------
// Cursor Exporter
// -----------------------------------------------------------------------------

export function exportCursor(
  resolved: ResolvedConfig,
  _options?: { agentsMdContent?: string }
): ExportResult[] {
  const results: ExportResult[] = [];
  const rules = filterRulesForTarget(resolved.rules, "cursor");

  // Export each rule as a separate .mdc file
  for (const rule of rules) {
    const id = rule.id.replace("rule:", "");
    const content = `---
# ${generateHeader(resolved, "yaml").trim().replace(/^# /gm, "").replace(/\n/g, "\n# ")}
---

${rule.content}
`;

    results.push({
      target: "cursor",
      filePath: `.cursor/rules/${id}.mdc`,
      content,
      isUserLevel: false,
    });
  }

  return results;
}

// -----------------------------------------------------------------------------
// Copilot Exporter
// -----------------------------------------------------------------------------

export function exportCopilot(
  resolved: ResolvedConfig,
  options?: { agentsMdContent?: string; includeAgentsMd?: boolean }
): ExportResult[] {
  const rules = filterRulesForTarget(resolved.rules, "copilot");

  if (rules.length === 0 && !options?.agentsMdContent) {
    return [];
  }

  const header = generateHeader(resolved, "markdown");
  let content = header + "# Copilot Instructions\n\n";

  // Add AGENTS.md content if configured
  if (options?.includeAgentsMd && options?.agentsMdContent) {
    content += "## Project Context (from AGENTS.md)\n\n";
    content += options.agentsMdContent;
    content += "\n\n---\n\n";
  }

  content += rules.map((rule) => rule.content).join("\n\n---\n\n");

  return [
    {
      target: "copilot",
      filePath: ".github/copilot-instructions.md",
      content,
      isUserLevel: false,
    },
  ];
}

// -----------------------------------------------------------------------------
// Claude Exporter
// -----------------------------------------------------------------------------

export function exportClaude(
  resolved: ResolvedConfig,
  options?: { agentsMdContent?: string; includeAgentsMd?: boolean }
): ExportResult[] {
  const rules = filterRulesForTarget(resolved.rules, "claude");

  if (rules.length === 0 && !options?.agentsMdContent) {
    return [];
  }

  const header = generateHeader(resolved, "markdown");
  let content = header;

  // Add AGENTS.md content first if configured
  if (options?.includeAgentsMd && options?.agentsMdContent) {
    content += "## Project Context (from AGENTS.md)\n\n";
    content += options.agentsMdContent;
    content += "\n\n---\n\n";
  }

  content += rules.map((rule) => rule.content).join("\n\n---\n\n");

  return [
    {
      target: "claude",
      filePath: "CLAUDE.md",
      content,
      isUserLevel: false,
    },
  ];
}

// -----------------------------------------------------------------------------
// MCP Exporter
// -----------------------------------------------------------------------------

interface McpClientConfig {
  mcpServers: Record<
    string,
    {
      command?: string;
      args?: string[];
      env?: Record<string, string>;
      url?: string;
    }
  >;
}

function buildMcpClientConfig(
  servers: McpServerDefinition[],
  variables: Record<string, string>
): McpClientConfig {
  const mcpServers: McpClientConfig["mcpServers"] = {};

  for (const server of servers) {
    const id = server.id.replace("mcp:", "");

    if (server.transport === "stdio") {
      const expanded = expandVariablesInObject(
        {
          command: server.command,
          args: server.args,
          env: server.env,
        },
        variables
      );

      mcpServers[id] = {
        command: expanded.command,
        args: expanded.args,
        env: expanded.env,
      };
    } else if (server.transport === "http") {
      const expanded = expandVariablesInObject(
        {
          url: server.url,
        },
        variables
      );

      mcpServers[id] = {
        url: expanded.url,
      };
    }
  }

  return { mcpServers };
}

export function exportMcp(
  resolved: ResolvedConfig,
  target: McpExportTarget,
  options: {
    repoRoot: string;
    home: string;
    userLevel?: boolean;
  }
): ExportResult[] {
  const servers = resolved.mcpServers;

  if (servers.length === 0) {
    return [];
  }

  const variables = {
    repoRoot: options.repoRoot,
    home: options.home,
    workspaceFolder: options.repoRoot,
  };

  const config = buildMcpClientConfig(servers, variables);

  // Add generation metadata
  const outputConfig = {
    _generated: {
      by: `infrax v${resolved.meta.version}`,
      hash: resolved.meta.configHash,
      at: resolved.meta.timestamp,
      warning: "DO NOT EDIT. Run 'infrax export mcp' to regenerate.",
    },
    ...config,
  };

  const content = JSON.stringify(outputConfig, null, 2);

  // Determine file path based on target
  let filePath: string;
  let isUserLevel = false;

  switch (target) {
    case "vscode":
      filePath = ".vscode/mcp.json";
      break;
    case "cursor":
      if (options.userLevel) {
        filePath = `${options.home}/.cursor/mcp.json`;
        isUserLevel = true;
      } else {
        filePath = ".cursor/mcp.json";
      }
      break;
    case "claude-desktop":
      // Claude Desktop is always user-level on macOS
      filePath = `${options.home}/Library/Application Support/Claude/claude_desktop_config.json`;
      isUserLevel = true;
      break;
    case "amazonq":
      if (options.userLevel) {
        filePath = `${options.home}/.aws/amazonq/mcp.json`;
        isUserLevel = true;
      } else {
        filePath = ".amazonq/mcp.json";
      }
      break;
    default:
      throw new Error(`Unknown MCP export target: ${target}`);
  }

  return [
    {
      target,
      filePath,
      content,
      isUserLevel,
    },
  ];
}

// -----------------------------------------------------------------------------
// Main export function
// -----------------------------------------------------------------------------

export interface ExportOptions {
  repoRoot: string;
  home?: string;
  targets?: ExportTarget[];
  mcpTargets?: McpExportTarget[];
  userLevel?: boolean;
  /** AGENTS.md content to include in exports */
  agentsMdContent?: string;
  /** Which targets should include AGENTS.md content */
  agentsMdIncludeIn?: "claude" | "all" | "none";
}

export function exportConfig(
  resolved: ResolvedConfig,
  options: ExportOptions
): ExportResult[] {
  const results: ExportResult[] = [];
  const home = options.home ?? process.env.HOME ?? "";

  const targets = options.targets ?? ["cursor", "copilot", "claude"];
  const agentsMdIncludeIn = options.agentsMdIncludeIn ?? "claude";

  for (const target of targets) {
    const includeAgentsMd =
      agentsMdIncludeIn === "all" ||
      (agentsMdIncludeIn === "claude" && target === "claude");

    switch (target) {
      case "cursor":
        results.push(
          ...exportCursor(resolved, {
            agentsMdContent: options.agentsMdContent,
          })
        );
        break;
      case "copilot":
        results.push(
          ...exportCopilot(resolved, {
            agentsMdContent: options.agentsMdContent,
            includeAgentsMd: includeAgentsMd && agentsMdIncludeIn === "all",
          })
        );
        break;
      case "claude":
        results.push(
          ...exportClaude(resolved, {
            agentsMdContent: options.agentsMdContent,
            includeAgentsMd,
          })
        );
        break;
      case "mcp":
        // MCP handled separately via mcpTargets
        break;
    }
  }

  // Handle MCP exports
  if (options.mcpTargets) {
    for (const mcpTarget of options.mcpTargets) {
      results.push(
        ...exportMcp(resolved, mcpTarget, {
          repoRoot: options.repoRoot,
          home,
          userLevel: options.userLevel,
        })
      );
    }
  }

  return results;
}
